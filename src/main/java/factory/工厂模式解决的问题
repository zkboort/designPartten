   在实际的设计中，往往针对的是大量的产品族进行设计而不是某一单一的个体而设计，在一个体系下往往有着大量的相似但又不同的产品；如何定义构造对象
就不再是我们关注的重点，这种规范的产品线面前如何控制生产对象的流程线才是中心。
   在生产过程中，我们通常对对象的产生需要去添加过修改一些东西，例如生产对象时打印日志、加权限、价修饰等，这种灵活控制需要工厂模式。
   同时对于解耦合的要求也是不能断的，因为一个产品线肯定的是要考虑经常更换产品的需求的，如果耦合度太高势必会增加我们的优化和维护的成本。所以工厂模式考虑到生产的同一产品种类众多，所以会设计专门生产产品的顶层接口。
然后由具体的实现类们（工厂）去实现不同的产品构建出对象，如果要修改产品就只在工厂类里面区修改即可，调用者只需负责调用工厂生产对象的方法拿到对象；
这样将生产对象和使用对象进行分离就很好的使得程序从原来new对象的关联关系转换为依赖关系使得耦合度大大降低了。
   对于简单工厂和工厂方法模式来说，生产同级别的产品是满足需求的,它的特点是对单个产品扩展是非常方便的，这样设计没问题，但是当我们有不同的生产线，生产完全不同的不同级别产品时（如苹果
：苹果手机、苹果电脑、苹果ipad、苹果耳机等）这两种工厂设计模式就无法满足程序的解耦合；而抽象工厂正对于某一个产品族进行整体规范，扩展一个产品族
就很方便，但是单独增加一个产品就会影响代码的耦合度。
    但是，无论是工厂方法、还是抽象工厂都有自己的缺点；无法做到灵活地扩展产品