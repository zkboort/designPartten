基本概念：

进程：一个运行的程序所需要的所有资源，cpu资源分配的基本单位，独立的地址空间（进程与进程相互隔离），进程切换开销大
线程：进程下的基本执行序列，没有单独的地址空间；线程共享同一进程下的全局变量、静态变量等数据且有自己的堆栈和局部变量，线程切换开销较小

同步Sync：同步就是必须一件一件事做，等前一件做完了才能做下一件事
异步Async：异步与同步相对，当一个异步过程调用发出后，调用者在没有得到结果之前，就可以继续执行后续操作。
          当这个调用完成后，一般通过状态、通知和回调来通知调用者，一般有比较耗时的操作存在于流程中时就考虑异步的设计。

并发：同一时间段内有多个程序处于运行状态，但是cpu一个时刻只能执行一个程序，所以会将运行时间分配给多个程序，每个程序执行一会儿。
     其中一个程序获得执行时间时，其他程序暂时挂起。
并行：都多个cpu时，那么就可同时执行多个程序，不需要将执行时间分配给多个程序。

可重入锁：该锁支持一个线程对同一个资源进行多次加锁。
独占式锁：用一时刻只能被一个线程获取，其他线程在队列中等待
共享式锁：
互斥锁：阻塞自身线程,等待释放锁
自旋锁：是不阻塞自身,而是在一个循环中等待释放锁,而且一直访问查看是否释放锁.这就是自旋锁

CAS原理（compare and swap）：CAS其实是无锁的,它只是抱着一种乐观的态度,认为自己可以完成任务,但是多个线程同时对一个变量进行CAS操作,
          只有一个操作可以完成.未完成的线程不会挂起,只是收到一个通知,告知失败.说它是无锁,是指硬件层面是无锁的,CAS操作只是一个的指令.

AQS原理(Abstract Queued synchronized )：
 Semaphore 许可信号：线程竞争获取许可信号，线程得到许可信号后开始执行业务逻辑，完了后释放许可信号
           获取信号：Semaphore.acquire();
           释放信号：Semaphore.release();
 AQS中最重要的是其维持的一个单一的状态变量state(int),不同类型的锁机制就是通过对state的不同的定义来实现的.
 state的操作方式：
    独占式方法：
      获取资源 acquire(int arg)，会对中断操作进行响应的 acquireInterruptibly(int arg)：
      释放资源 release(int arg)：
    共享式方法：
      获取资源 acquireShared(int arg)，会对中断操作进行响应的 acquireSharedInterruptibly(int arg)：
      释放资源 releaseShared(int arg)：

 锁支持工具：提供硬件层次的挂起和唤醒锁
 rt.jar.LockSupport:
         park():如果当前线程持有到许可证,调用pack方法后会马上返回,结束方法,如果没有持有许可证,就会挂起处于阻塞状态,线程默认情况下没有许可证
         unpark(Thread thread):获取许可证.有几种情况:
             先执行unpack,再执行pack,pack会直接返回,结束方法.
             先执行pack,线程挂起,再执行unpack,线程被唤醒.